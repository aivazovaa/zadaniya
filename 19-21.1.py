from functools import *  #импортируем functools, чтобы избежать переполнение рекурсии
def moves(h): #создаем функцию, которая будет генерировать всевозможные ходы из конкретных позиций
     a, b = h
     return (a+1, b),(a, b+1),(a+b, b),(a, b+a)
@lru_cache(None) #подключаем cache, чтобы программа не пересчитывала значения каждый раз заново
def game(h): #создаем функцию, которая будет определять, какой является позиция для игрока, где 'W' - победа уже достигнута и игра окончена, 'P1'/'P2' - первый игрок (Артём) выиграл первым или вторым ходом соответственно, 'V1'/'V2' - второй игрок (Эрик) выиграл первым или вторым ходом соответственно.
    if sum(h) >= 179: return 'W'
    if any(game(i) == 'W' for i in moves(h)): return 'P1' #при помощи генераторов перебираем возможные ходы от конкретного h и, отталкиваясь от них, обозначаем конкретные позиции
    if all(game(i) == 'P1' for i in moves(h)): return 'V1'
    if any(game(i) == 'V1' for i in moves(h)): return 'P2'
    if all(game(i) == 'P1' or game(i) == 'P2' for i in moves(h)): return 'V2'

for s in range(1, 156): #перебираем и выводим все возможные значения
     if game((23, s)):
         print(s, game((23, s)))
#далее сверяем вывод с условием и находим то, что нам нужно